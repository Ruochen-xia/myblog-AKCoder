# 1.字符串
## 一.为什么要用字符串？
当存储一个字符时，我们会用到$char$类型。但是，很多时候我们要存储多个字符，这时候，我们就要用**字符串**。
## 二.怎么食用字符串
`.size()` 与 `.length()` 是求字符串的长度。  时间复杂度 $O(len)$

`.push_back()` 与 `+=` 是在串尾加新字符/串。   时间复杂度 $O(1)/O(len)$

`.insert(pos,str)` 是在第 $pos$ 的位置上插入字符串 $str$。  时间复杂度 $O(size)$

`.substr(pos,len)` 是从第 $pos$ 的位置截取一个长度为 $len$ 的字符串。   时间复杂度 $O(len)$

`.erase(pos,len)` 是删除第 $pos$ 开始的 $n$ 个字符。   时间复杂度 $O(size)$

`.find(str,start)` 是从 $start$ 为起点字符串 $str$ 的位置。如果没有查找到字符串，则返回 $string::npos$ ，转换成 $int$ 大概是 $-1$。  时间复杂度 $O(nm)$

**[更多字符串的操作，请上 oi-wiki.com](http://oi-wiki.com/string/lib-func/)**

# 2.字符串 hash

字符串有一些比较良好的性质（比如每个元素的值域一般很小），所以我们可以利用这些性质对字符串匹配做一些优化，比如预处理出字符串的 $hash$ 值，通过比较 $hash$ 值来判断两个串是否相同。

## 性质
1. 两个 $hash$ 值不相同的字符串一定不相等
2. 两个 $hash$ 值相同的字符串不一定相等（因为 $hash$ 有可能冲突，只能说是大部分情况下相同，万一出题人特意卡 $hash$……）

## 防止 $hash$ 冲突的方法
其实 $hash$ 冲突无法防止，但可以降低冲突的概率。
1. 取一个较大的质数，比如 $1e9 + 7$ ，$114514$ ， $2^{62}-1$ 等……
2. $base$ 尽量随机，防止出题人卡你 $hash$

## 惨痛经历
### $11$ 发罚时也是绝了
![11发罚时是谁的一辈子](https://cdn.luogu.com.cn/upload/image_hosting/lcrh9cs3.png)

## 例题
[P3370 【模板】字符串哈希](https://www.luogu.com.cn/problem/P3370)

~~友情提醒：如果真的想好好练习哈希的话，请自觉。~~

此题即为`字符串哈希`的模版题！

计算字符串的 $hash$ 值时，我们一般把原串的 $B$ 进制数作为它的 $hash$ 值，这样比较方便计算，并且预处理之后，也可以 $O(1)$ 求出任意一个子串的 $hash$ 值。

建议别用自然溢出，不然被出题人卡了就老实了！

字符串的长度一般会很长， $int128$ 都存不下，怎么办？

~~高精度~~  `取模！`

建议自己手写 $add$ 与 $mul$ 函数，不然被出题人卡了就老实了

注意！！注意！！别 `#define int __uint128_t` ！！！！！

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;
#define ll long long
#define ull unsigned long long
const int MAXH = 10100;
const int INF  = 0x3f3f3f3f;
const ull mod = (1ull << 61) - 1;
const ull base = 152447;
inline int read()
{
  int x=0,f=1;char ch=getchar();
  while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
  while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
  return x*f;
}
ull get_hash(const string &s){
  int len = s.size();
  ull res = 0;
  for(int i = 0;i < s.size();i++){
    res = (__uint128_t(res) * base + s[i]) % mod;
  }
  return res;
}
int n;
string s[MAXH];
ull a[MAXH];
int ans = 0;
int main(){
  ios::sync_with_stdio(0);
  cin.tie(0),cout.tie(0);
  cin >> n;
  for(int i = 1;i <= n;i++){
    cin >> s[i];
    a[i] = get_hash(s[i]);
  }
  for(int i = 1;i <= n;i++){
    bool flag = 0;
    for(int j = i + 1;j <= n;j++){
      if(s[i] == s[j]){
        flag = 1;
        break;
      }       
    }
    if(!flag)
      ans++;
  }
  cout << ans << endl;
  return 0;
}
// 由于是vscode写的，所以排版有亿点不好
```

---
# 总结：hash 虽然很多能被某 $STL$ 给水掉，但他确实很重要，所以……

## 友情提醒：如果真的想好好练习哈希的话，请自觉。—— HansBug