# 生成树

生成树，就是在一个无向连通图中选择 $n - 1$ 条边，使得这 $n-1$ 条边构成了一棵树。

# 最小生成树

假设每一条边有边权，边权和最小的生成树就是最小生成树（MST）。

# 求法

## 1. Prim

这是一个点核心的算法。

每次选择点权最小的点，在扩展到邻居节点，这和 dijkstra 几乎一毛一样。

朴素时间复杂度：$O(n^2+m)$。

堆优化：$O((n+m)\log_2m)$

平衡树优化（实测更快一点）：$O((n+m)log_2m)$

代码：

```cpp
int Prim() {
  int ans = 0;
  priority_queue <Node> q;
  vector <int> dist(n + 1, inf), vis(n + 1, 0);
  dist[s] = 0;
  q.push({s, 0});
  while (!q.empty()) {
    int u = q.top().v, w = q.top().w;
    q.pop();
    if (vis[u]) continue;
    vis[u] = 1;
    ans += w;
    for (auto nxt : edges[u]) {
      int v = nxt.v, w = nxt.w;
      if (w < dist[v]) {
        dist[v] = w;
        q.push({v, dist[v]});
      }
    } 
  }
  return ans;
}
```

## 2.kruskal

这是一个边核心的算法。

每次选择边权最小的边，在判断有没有环。

怎么判断有没有环呢？

~~Tarjan~~ DSU！

代码：

```cpp
int kruskal() {
  vector <TreeNode> edges;
  n = read(), m = read();
  for (int i = 1; i <= n; i++) fa[i] = i;
  for (int i = 1; i <= m; i++) {
    int x = read(), y = read(), w = read();
    edges.push_back({x, y, w});
  }
  sort(edges.begin(), edges.end());
  int ans = 0, tot = 0;;
  for (auto [x, y, w] : edges) { // C++17
    x = find(x), y = find(y);
    if (x != y) {
      fa[x] = y;
      ans += w;
      tot++;
    }
  } 
}
```



# 例题：

### [C - 营救 ](https://vjudge.net/problem/洛谷-P1396/origin)

跑一下 kruskal，如果 `find(s) == find(t)` 直接输出即可。

```cpp
#include <bits/stdc++.h>

using namespace std;
#define ll long long
#define ull unsigned long long
#define db double
#define sz(x) ((int)x.size())
#define inf (1 << 30)
#define pb push_back
typedef pair<int, int> PII;
const int N = 1e5 + 7;
const int P = 998244353;
int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (!(ch >= '0' && ch <= '9')) {if (ch == '-') f = -f;ch = getchar();}
  while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();}
  return x * f;
}
int n, m, fa[N], s, t;
struct TreeNode {
  int x, y, w;
  bool operator < (const TreeNode &A) const {
    return w < A.w;
  }
};
vector <TreeNode> edges;
int find(int x) {
  return fa[x] == x ? x : fa[x] = find(fa[x]);
}
int main() {
  n = read(), m = read(), s = read(), t = read();
  for (int i = 1; i <= n; i++) fa[i] = i;
  for (int i = 1; i <= m; i++) {
    int x = read(), y = read(), w = read();
    edges.push_back({x, y, w});
  }
  sort(edges.begin(), edges.end());
  int ans = inf, tot = 0;;
  for (auto [x, y, w] : edges) {
    x = find(x), y = find(y);
    if (x != y) {
      fa[x] = y;
      tot++;
      if (find(s) == find(t)) {
        ans = min(ans, w);
      }
    }
  } 
  printf("%d\n", ans);
  return 0;
}
```

### [D - Out of Hay S ](https://vjudge.net/problem/洛谷-P1547/origin)

就是求一个 max 即可。

### [E - 买礼物 ](https://vjudge.net/problem/洛谷-P1194/origin)

把每一个优惠边权设成 A，再把不优惠连向 0 号点，再搞一遍 MST。

```cpp
#include <bits/stdc++.h>

using namespace std;
#define ll long long
#define ull unsigned long long
#define db double
#define sz(x) ((int)x.size())
#define inf (1 << 30)
#define pb push_back
typedef pair<int, int> PII;
const int N = 5000 + 7;
const int P = 998244353;
int read() {
  int x = 0, f = 1;
  char ch = getchar();
  while (!(ch >= '0' && ch <= '9')) {if (ch == '-') f = -f;ch = getchar();}
  while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();}
  return x * f;
}
int n, m, fa[N], a[N][N];
struct TreeNode {
  int x, y, w;
  bool operator < (const TreeNode &A) const {
    return w < A.w;
  }
};
vector <TreeNode> edges;
int find(int x) {
  return fa[x] == x ? x : fa[x] = find(fa[x]);
}
int main() {
  m = read(), n = read();
  for (int i = 1; i <= n; i++) fa[i] = i;
  for (int i = 1; i <= n; i++)
    for (int j = 1; j <= n; j++) {
      a[i][j] = read();
    }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
      if (a[i][j]) {
        edges.pb({i, j, a[i][j]});
      }
    }
  }
  for (int i = 1; i <= n; i++) {
    edges.pb({0, i, m});
  }
  sort(edges.begin(), edges.end());
  int ans = 0, tot = 0;;
  for (auto [x, y, w] : edges) {
    x = find(x), y = find(y);
    if (x != y) {
      fa[x] = y;
      ans += w;
      tot++;
    }
  } 
  printf("%d\n", ans);
  return 0;
}
```



# 后记

警钟敲烂：在写并查集时请不要带 $\log$！！！