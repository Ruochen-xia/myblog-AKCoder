| question | T1  | T2  | T3  | T4  | T5  | T6  | T7  |  T8  | T9  |all|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:| :-: |
| want scores  | 100pts  |  100pts | 100pts  | 100pts  | 100pts  | 30pts  | 100pts  | 0pts  | 0pts  | 630pts   |
| scores  | 100pts  | 100pts  | 25pts  | 100pts  |100pts  | 0pts  | 100pts  | 18pts  |  0pts | 543pts   |

---

# 前言
~~老师也太看的起我们了！~~
## 下一次考试我一定仔细看题！！！！！！！！！
## 仔细看数据范围 >_<


# T3
错误原因：$1 \le x < 2^{64}$，没有 `#define int unsigned long long` ，可惜了 $75pts$ 了 >_<

正确思路：可以使用单调队列解决，使用 $STL$ 中的双端队列 $deque$ ,但在使用的过程中需要转化 $q.front()$ 的类型，例如 `q.front()<=i-k` 是不行的，而 `q.front()+k<=i` 是可以的。因为 `q.front()` 是 `unsigned int`，如果 $x < 0$ ，那么就很爽了！！！ 

单调队列的基本思想是插入合法元素，踢出过期元素，也就是传说中的“如果一个人比你小还比你强，那你就寄了”。

总结：下次记得看数据范围，计算 $int$ -> $long$ $long$ -> $unsigned$ $long$ $long$ -> __  $int128$ _ $t$ -> __ $uint128$ _ $t$ >_<

# T6
错误原因：没记录彩珠的 $id$。  $(╥﹏╥)$

正确思路：可以食用单调队列！！！用一个单调队列维护，如果区间包含所有的元素，就更新，否则弹出队头来找出更短的区间。

总结：还是得好好看题

# T8 
错误原因：判成了左开右开区间了

正确思路：左右各跑一遍单调队列，再判断是否左右都有比它拥挤的就好了。

总结：还是得注意细节

# T9
错误原因：考试时看题目太长了没做（时间不够了）

正确思路：和 [P2629 好消息，坏消息](https://www.luogu.com.cn/problem/P2629) 很像，破环成链，因此我们可以简化为，从第 $i$ 个加速器抵达其相邻的加速器，是将原速度 $+e_i-d_i$ 的过程。

# 总结：
1. 不要 `#define int long long`
2. 注意看数据范围
3. 不要看题目长就不去看
4. 要计算时间复杂度
5. 能不用暴力就不用
6. 注意细节