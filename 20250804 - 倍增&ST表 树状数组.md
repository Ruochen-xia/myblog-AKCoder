## 倍增&ST表

### 倍增基本思想
倍增是一种通过预先计算和存储指数级间隔的信息，将线性时间操作优化为对数时间的技术。核心思想是"以2的幂次为步长"进行跳跃或查询。

### ST表 
ST 表是一种用于解决 RMQ (区间最值查询)问题的数据结构，通过预处理 $O(nlogn)$ 时间，支持 $O(1)$ 查询。

优点：单次询问是 $O(1)$ 的

缺点：无法在低时间复杂度修改 $ST$ 表

### 典型应用
1. **LCA(最近公共祖先)**: 通过预处理每个节点向上$2^k$ 层的祖先，快速找到两个节点的LCA
2. **快速幂算法**: 将指数分解为二进制位，通过平方的方式快速计算幂次

## 例题：[最近公共祖先（LCA）](https://www.luogu.com.cn/problem/P3379)

## 方法 ( $T$ 次询问)

### 1. 暴力法
记录深度，把深度较深的节点向上移动 

时间复杂度： $O(Tn)$

### 2. 倍增
预处理每个节点向上 $2^k$ 层的祖先

查询时通过二进制跳跃快速找到 $LCA$

```cpp
dp[i][j] = dp[dp[i][j-1]][j-1];
```

时间复杂度： $O(T\log_2n)$

### 3.dfs序

对树进行 $dfs$ 遍历，记录访问顺序和深度

记录每个节点首次出现的位置

用 $ST$ 表来求出两个节点欧拉序之间深度最小的节点

时间复杂度：$O(nlog_2n + T)$

$>$ __ $<$   我下次再也不用 $RMQ$ 来求 $LCA$

## 树状数组

### 基本概念
树状数组是一种**高效维护前缀和**的数据结构，支持：
- **单点更新**   $O(logn)$ 
- **区间求和**   $O(logn)$ 

**空间复杂度**：O(n)

**优势**：
  - 代码简洁（ $<20$行代码）
  - 常数因子小（相比线段树）
  - 内存效率高（相比线段树）

**劣势**：
- 无法操作区间翻转

```
int lowbit(int x){
	return x & -x;
}

void modify(int x,int val,int c[]){
	while(x <= n){
		c[x] += val;
		x += lowbit(x);
	}
}

int get_sum(int x,int c[]){
	int res = 0;
	while(x > 0){
		res += c[x];
		x -= lowbit(x);
	}
	return res;
}
```


### 结构

```
       8
    /     \
   4       12
  / \     / \
 2   6   10  14
/ \ / \ / \ / \
1 3 5 7 9 11 13 15
```


# 所以！还是~~写线段树吧~~写树状数组吧

# 彩蛋

## [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)

### AC树状数组做法

```cpp
#include <bits/stdc++.h>

using namespace std;
#define ll long long
const int MAXN = 1e5 + 7;
const int mod = 1e9 + 7;
const int INF = 0x3f3f3f3f;
ll n,m;
ll a[MAXN];
ll c1[MAXN],c2[MAXN];

ll lowbit(ll x){
	return x & -x;
}

void modify(ll x,ll val,ll c[]){
	while(x <= n){
		c[x] += val;
		x += lowbit(x);
	}
}

ll get_sum(ll x,ll c[]){
	ll res = 0;
	while(x > 0){
		res += c[x];
		x -= lowbit(x);
	}
	return res;
}

void init(){
	
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin >> n >> m;
	for(int i = 1;i <= n;i++){
		cin >> a[i];
		modify(i,a[i]-a[i-1],c1);
		modify(i,(i - 1) * (a[i] - a[i-1]),c2);
	}
	while(m--){
		ll opt,x,y,k;
		cin >> opt >> x >> y;
		if(opt == 1){
			cin >> k;
			modify(x,k,c1);
			modify(y+1,-k,c1);
			modify(x,k * (x - 1),c2);
			modify(y+1,-k * y,c2);
		}else{
			ll prefix_sum1 = 1LL * (x - 1) * 
				get_sum(x-1,c1) - get_sum(x-1,c2);
			ll prefix_sum2 = 1LL * y * 
				get_sum(y,c1) - get_sum(y,c2);
			cout << 1LL * prefix_sum2 - prefix_sum1 << endl; 
		}
	}
	return 0;
}
```